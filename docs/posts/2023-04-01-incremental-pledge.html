<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Incremental Privilege Reduction in Haskell on OpenBSD</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Björn Gohla</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../projects.html">Projects</a>
                <a href="../archive.html">Archive</a>
                <a href="../hireme.html">Hire Me</a>
            </nav>
        </header>

        <main role="main">
            <h1>Incremental Privilege Reduction in Haskell on OpenBSD</h1>
            <article>
    <section class="header">
        Posted on April  1, 2023
        
    </section>
    <section>
        <h1 id="outline">outline</h1>
<ul>
<li><p>privilege sets form a join lattice, hence a category. we take the
opposite, since we want to go from larger to smaller sets.</p></li>
<li><p>we want to automatically run <code>pledge</code> after every <code>IO</code> action, and
we need to pledge all promises, that might be needed by any action,
that is run later. on the other hand, for a given action we only
know which promises it needs.</p>
<p>we need to propagate needed promises backwards, and we might think
of defining</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  bind ::</span> (after <span class="op">~</span> before')</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=&gt;</span> <span class="dt">IxIO</span> before after a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IxIO</span> before' after' b)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> <span class="dt">IxIO</span> before after' b</span></code></pre></div>
<p>but if done this way, we have no way to express which promises the
second action itself needs, i.e., some <code>X</code> such that</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>before' <span class="op">~</span> after' ∪ <span class="dt">X</span></span></code></pre></div>
<p>let’s insert this equation in our definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bind ::</span> (after <span class="op">~</span> after' ∪ <span class="dt">X</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>     <span class="ot">=&gt;</span> <span class="dt">IxIO</span> before (after' ∪ <span class="dt">X</span>) a</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IxIO</span> (after' ∪ <span class="dt">X</span>) after' b)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">IxIO</span> before after' b</span></code></pre></div>
<p>we must also enforce that</p>
<pre><code>after ⊂ before
</code></pre>
<p>in particular</p>
<pre><code>(after' ∪ X) ⊂ before
</code></pre>
<p>(which we might be able to do using Orchard’s <code>IsSet</code> predicate)</p>
<p>We migth try to define the wrapper as follows, where we use type
class constraints</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IxIO</span> before after a <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IxIO</span><span class="ot"> ::</span> ( before <span class="op">~</span> (after ∪ x)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>   , <span class="dt">IsSet</span> before</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>   , <span class="dt">IsSet</span> after</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>   , <span class="dt">IsSet</span> x</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>   )</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">IxIO</span> before after a</span></code></pre></div>
<p>a concrete action would look like this</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pledgePutStrLn ::</span> ( before <span class="op">~</span> (after ∪ '[<span class="dt">Stdio</span>])</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IsSet</span> before</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IsSet</span> after</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IsSet</span> '[<span class="dt">Stdio</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IxIO</span> before after ()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>pledgePutStrLn s <span class="ot">=</span> <span class="fu">flip</span> <span class="dt">IxIO</span> (sing <span class="op">@</span>'[<span class="dt">Stdio</span>]) <span class="op">$</span> <span class="fu">putStrLn</span> s</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pledgeGetLine ::</span> ( before <span class="op">~</span> (after ∪ '[<span class="dt">Stdio</span>])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IsSet</span> before</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IsSet</span> after</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IsSet</span> '[<span class="dt">Stdio</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span> <span class="dt">IxIO</span> before after <span class="dt">String</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>pledgePutStrLn <span class="ot">=</span> <span class="fu">flip</span> <span class="dt">IxIO</span> (sing <span class="op">@</span>'[<span class="dt">Stdio</span>]) <span class="op">$</span> <span class="fu">getLine</span></span></code></pre></div>
<p>then using <code>bind</code> we would get</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span>  ( before <span class="op">~</span> (after ∪ '[<span class="dt">Stdio</span>])</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a> , <span class="dt">IsSet</span> before</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a> , <span class="dt">IsSet</span> after</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a> , <span class="dt">IsSet</span> '[<span class="dt">Stdio</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a> ) <span class="ot">=&gt;</span> <span class="dt">IxIO</span> before after <span class="dt">String</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> bind pledgeGetLine pledgePutStrLn</span></code></pre></div>
<p>(not so exciting)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runIxIO ::</span> <span class="dt">IxIO</span> before '[] a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div></li>
</ul>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
