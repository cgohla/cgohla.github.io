---
title: Graded Monads
---

Graded monads are great. In functional programming, for example, they
can be used to track certain sorts of external state at the type
level.

Graded monads generalise ordinary monads, let's see how: An ordinary
monad can be viewed as a lax 2-functor from the terminal 2-category 1
to the 2-category of large categories CAT.

The later contains the (idealized) category Hask as an object. And
it's the only one we care about here.  Let's note that the terminal
2-category 1 consists of a unique object, its identity arrow, and the
later's identity 2-arrow.

First, any lax 2-functor T : 1 -> CAT needs
to assign values for the unique object and for its identity (the image
of the identity 2-arrow is fixed by the choice of the 1-arrow).

Note that T does not need to preserve the identity arrow. That's
because it's lax.

So we define T by choosing a category as the image
of the unique object. Let's suppose we chose Hask.

Now we still get to freely choose an endomorphism of Hask, i.e., en
endofunctor. Let's also call it T.

We already see some structure
emerge: because T : Hask -> Hask is an endofunctor, we can take its
powers: T^0, T, T^2, T^3 ... by composing T with itself repeatedly.

T^0 is of course the identity functor of Hask.  By contrast, if T were
a strict 2-functor, our image T would have to be the identity functor
of Hask, and equal to all its powers. NOT SO HERE.

The relationship
between the identity of Hask and T : Hask -> Hask is not completely
arbitrary however: the definition of a lax 2-functor requires us to
provide a 2-arrow Id_Hask => T, i.e., a natural transformation.

In Haskell notation this is a function eta :: a -> T a .  As for the
identity, so for the composition: since T is lax, it is only required
to preserve composites up to 2-arrow. For our Hask endofunctor T this
means we require a natural transformation T^2 => T, let's call it mu.

In Haskell notation this is a mu :: T(T a) -> T a .  (The natural
transformations eta and mu are better known in Haskell as 'return' and
'join' from the Control.Monad module) 

Continuing with our story: for
(T, eta, mu) to actually be a monad the natural transformations eta
and mu have to satisfy two axioms usually called UNIT and
ASSOCIATIVITY. Here is a picture from Wikipedia Monad (category
theory) - Wikipedia
https://en.m.wikipedia.org/wiki/Monad_(category_theory) Image 

(Note
that the 2-arrows, i.e., natural transformations, of the 2-category
CAT are drawn as plain arrows here.)  

Now the big shocking reveal is
that the axioms for our lax 2-functor T : 1 -> CAT look exactly like
the monad axioms for T : Hask -> Hask.  

Disregarding the fact that I
have not actually given a precise definition of lax 2-functors, we now
take it as established that there is a bijection between such T with
object value Hask and monads T on the category Hask.  

Now, to obtain
the concept of a graded monad we need to replace the terminal
2-category 1 in the story above with something else. That something
else is going to be a monoid. Let me explain what I mean by that.

Monoids, i.e., sets with an associative and unital operation can be
viewed as categories: introduce an object, let's call it *, and let
the morphisms * -> * be the elements of the monoid.  Then the monoid
operation is a composition operation for this category and the monoid
unit is the identity morphism of the single object *.

(The object * is not to be confused with the Type kind in Haskell.)

So a monoid in a way IS a category. But we really needed to replace
the terminal 2-category 1 with another 2-category, since we want to
talk about lax 2-functors out of it. This is easily fixed: just add in
an identity 2-arrow for each 1-arrow.  Thus, in the same vein, a
monoid in a way IS a 2-category, and this shifting of viewpoint does
not require supplying any new data, but merely the use of a more
powerful language to talk about the same thing.  As an example, let's
consider the monoid with elements 0 and 1 and the usual multiplication
as the operation. Then clearly 1 is the unit. As a category it has
arrows 0 : * -> * and 1 : * -> * and composition is just
multiplication, as we have said. Let's call this category B.  We view
B as a 2-category, and consider what it means to have a lax 2-functor
T : B -> CAT. T(*) is some category, for concreteness, we can continue
to assume that's Hask. Since B has 2 distinct arrows we get 2 Hask
endo functors T_0 and T_1 : Hask -> Hask.  Note that T_1 is the image
of the identity 1 : * -> * under the lax 2-functor, so laxness means
there must be a natural transformation eta : Id_Hask => T_1.  Also by
laxness of T, as part of its data, there are natural transformations
mu : T_i T_j => T_k where i and j can be 0 or 1 and k is i×j. (Note
that these are 4 different mu's, but I didn't want to clutter the
notation with indices.)  In Haskell notation we might write these
natural transformations as eta : a -> T 1 a and mu : T i (T j a) -> T
(Mult i j) a . (Note that the first type parameter of T is of a data
kind with constructors 0 and 1, Mult is a type family implementing
multiplication for them.)  The natural transformations need to satisfy
unit and associativity laws. These can be obtained from the diagrams I
included earlier, by inserting indices i, j and i×j in the right
places.  Now, to see that graded monads generalise monads we only need
to consider the fact that the trivial monoid having a single element
gives exactly the terminal category when promoted to a 2-category in
the way we I described.)  Furthermore, homomorphisms of monoids, i.e.,
maps preserving monoid unit and composition, can be promoted to strict
2-functors in an obvious way. In particular for an arbitrary monoid M
there is always a unique homomorphism e: 1 -> M picking out the unit.
If we write the homomorphism e promoted to a strict 2-functor as E,
and if we have a lax 2-functor T : M -> CAT then by composing these T
E : 1 -> CAT, we obtain an ordinary monad contained in the graded
monad given by T.  There is a type class interface for graded monads
implemented in hackage.haskell.org/package/effect… by @dorchard
. Using the RebindableSyntax extension of GHC or the upcoming
QualifiedDo extension we can even write do blocks that use graded
monads.  effect-monad Embeds effect systems and program logics into
Haskell using graded monads and parameterised monads
https://hackage.haskell.org/package/effect-monad To my knowledge, the
primordial source for lax 2-functors is
link.springer.com/chapter/10.100… by Jean Bénabou. Although he calls
them simply morphisms of bicategories. The example section shows how
versatile the notion is.  Introduction to bicategories
https://link.springer.com/chapter/10.1007/BFb0074299 In particular he
describes 'polyads' these are also known today as indexed monads. I
might write about them some other time.  THE END
