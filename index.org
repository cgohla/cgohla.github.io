# -*- mode: org; -*-

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/bigblow/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/bigblow/css/bigblow.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/bigblow/css/hideshow.css"/>

#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/jquery-1.11.0.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>

#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/jquery.localscroll-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/jquery.zclip.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/bigblow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/bigblow/js/hideshow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script> MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']],    packages: ['base', 'newcommand', 'configMacros']  },  svg: {    fontCache: 'global'  }}; </script>

#+HTML_HEAD: <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

#+TITLE: Björn Gohla
#+AUTHOR: Björn Gohla
#+EMAIL: b.gohla@gmx.de

* Björn Gohla
  - My github profile is [[https://github.com/cgohla][here]],
  - my other github profile is [[http://github.com/bgohla][here]]. 
  - I'm on twitter as [[https://twitter.com/6d03][6d03]]. 
  - My arXiv page is [[https://arxiv.org/search/?searchtype=author&query=Gohla%252C+B][here]].

* Computing
** Basic Rewriting

   Let me talk a little bit about a cool paper on rewriting theory
   that I'm reading:
   https://dl.acm.org/citation.cfm?doid=322217.322230

   Let's say have a set of items, and you're allowed to hold on to one
   item at a time.

   And there is a bunch of rules, saying which items you're allowed to
   trade for which other items. An obvious question is: Can you get a
   specific item, starting with a given one through repeated
   exchanges?

   If the items are a cherry, a pear, and an egg; and rules saying you
   may exchange Cherries ⇀ Pear, Pear ⇀ Peach, and Egg ⇀ Pear; then
   you can obviously get the Egg from the Cherries in two steps (one
   rule has to be used backwards).

   We would like to know for which rule sets we could program a
   computer to decide this question for us. The paper tells us under
   which conditions on a sets of rules this is possible (and some
   generalizations and applications, which I'm not going to mention).

   Small aside: The problem is trivial when the set of items is
   finite, because we can just enumerate all the possibilities in a
   finite number of steps. The problem becomes interesting, when, for
   example, the items being exchanged are the terms in a language.

   So we have to be a bit more clever.

   First, let's agree to treat the rules as unidirectional. We can use
   them both ways, but they have to have a direction and we are mostly
   interested in using them in the forward direction.

   A property that our rule set might have is called «confluence»:
   Starting with any item α, and any two sequences of exchanges
   yielding ξ and υ respectively, there is always an item β, that can
   be obtained from both ξ and υ through further sequences of
   exchanges.
   
   In a picture:

   α → ξ
   ↓   ↓
   υ → β

   where the arrows are sequences of forward exchanges ⇀ ⋯ ⇀.
   
   The first important (easy) result in the paper now says that any
   sequence of forward and backward applications of our exchange
   rules, e.g. ↼ ↼ ↼ ⇀ ↼ ⇀ ↼ ⇀ ↼ ⇀ ⇀, can be replaced by a sequence of
   just forward applications followed by a sequence of just backward
   applications, e.g. ⇀ ⇀ ⇀ ↼ ↼, _if_ our rule set has the confluence
   property.

   Another property that our rule system may have, is called
   «well-foundedness»: It requires that, if we start with any item, say
   α, and we keep using any applicable exchange rule in the forward
   direction, we must eventually get some item β, that can not be
   exchanged for anything else.

   I.e., in a well-founded rule system no sequence of forward
   exchanges can go on forever; arguably an essential property if we want
   to write a computer program, that always gives an answer.

   Now, if our rule system has both the confluence and the
   well-foundedness property, then not only will every sequence of
   exchanges eventually end, but for every α we start with, there is
   exactly one β that it can end with.

   And this is actually easy to see: lets say you started with α, by
   well-foundedness, after a finite number of forward steps you can't
   go any further and end up with β; but maybe if you had used a
   different sequence of steps, you would have ended up with β'.

   Now confluence tell us there are sequences of further steps, that
   would give us a γ from both β and β'. But how could we possibly
   find these sequences?

   Luckily, our rule system is well-founded, meaning no further
   exchanges of β and β' are possible, so the two sequences we would
   need to find are empty, meaning β and β' (and the putative γ) have
   to be equal.

   So now we have a recipe for solving our initial question of whether
   we can get one item from another by repeated forward and backward
   exchanges (under the assumption that our rule system is confluent
   and well founded):

   Take both items, keep applying the exchange rules in the forward
   direction until you can't go further and you get two items uniquely
   determined by the starting points; compare them, if they are equal,
   the answer is yes; otherwise it is no.

   These are the generalities that I wanted to share. The actual hard
   work is of course in showing that a given rule system actually is
   well-founded and confluent.

* Math
** Highlight: The Categorical Origins of Lebesgue Integration
   
   I want to discuss a recent pre-print by Tom Leinster, namely [[https://arxiv.org/abs/2011.00412][The
   categorical origins of Lebesgue integration]].

   It is a very nice exposition of some very important gadgets in
   functional analysis, namely the vector spaces $L^p([0,1])$ and
   $\ell^p$. The part that really caught interest is that the
   aforementioned spaces are initial $F$-algebras in normed vector
   spaces.

   Let me explain why this is nice: \(F\)-algebras are a very basic
   concept from categorical algebra: if $F$ is a functor $F: C→C$,
   then an $F$-algebra on an object $X$ is a $C$-morphism $\xi:
   FX→X$. A morphism $f: X → Y $ is an $F$-algebra morphism if
   $\upsilon\circ Ff = f \circ \xi$.

   A simple example over sets would be the functor $X \mapsto 1+X$. In
   this case an algebra on a set $X$ is a pair of functions $1→X$ and
   $X→X$. It's easy to see that the natural numbers $N$ are such an
   algebra, where the first function picks the number 0, and the
   second is the successor function. 

   What makes the natural numbers special among all algebras of this
   kind is that for any other such algebra $\alpha: 1+A→A$ there is a
   unique function $f:N→A$, which is an algebra homomorphism.  This is
   essentially a restatement of the Peano axioms.

   Categorically we say that $1+N→N$ is initial in the category of
   $(1+\_)$-algebras.

   Now let us turn our attention to the category $\mathrm{Ban}$ of
   Banach spaces and contractive maps, i.e., linear maps of norm at
   most 1. Let's say the ground field is $\mathbb{R}$

   The field $\mathbb{R}$ itself is of course a Banach space in a
   natural way, so it is an object in $\mathrm{Ban}$. A morphism $R→V$
   to another Banach space corresponds to a choice of vector $v$ in
   $V$ of norm at most 1. In particular, such Banach spaces with a
   choice of vector of norm less than 1 form a category
   $\mathbb{R}/\mathrm{Ban}$ where the morphisms are linear
   contractions taking chosen vector to chosen vector. This cateogry
   has an initial object, namely $\mathbb{R}$ with chosen element 1,
   meaning there is a unique linear contraction $(\mathbb{R},1)→(V,v)$
   for every $(V,v)$.

   We are now going to define an endo-functor $F_p$ on $\mathrm{Ban}$
   and extend it to $\mathbb{R}/\mathrm{Ban}$ where $p\geq 1$ is a
   real number: $F_p$ takes the vector space $V$ to the direct sum
   $V\oplus V$ with the norm given by the $p$-average $$|v+v'| =
   \left(\frac{1}{2}(|v|^p+|v'|^p)\right)^{\frac{1}{p}}$$. 

   To extend $F_p$ to $\mathb{R}/\mathrm{Ban}$ we observe that if our
   chosen vector in $V$ is $v$ then in $V\oplus V$ we can choose
   $v+v$, and its norm will be exactly $|v|$ with the norm taken in
   $V$. If the vector space in question was $\mathbb{R}$, then $F_p$
   of it is $\mathbb{R}^2$ with the (appropiately scaled)
   $p$-norm. Because $(\mathbb{R},1)$ is initial in our category, The
   diagonal $\mathbb{R}→\mathbb{R}^2$ is the uniquely determined
   contractive linear map. 

   If we keep iterating $F_p$ we get
   $F_^n(\mathbb{R},1)=(\mathbb{R}^{2^n},e)$ where $e$ is all 1s and
   the norm is the $p$-average over all the entries in a vector. For
   convenince let's $E_n=F_^n(\mathbb{R},1)$. We get norm preserving
   linear maps $E_n→E_{n+1}$ that duplicate every entry in a row
   vector.

   We obtain a diagram
   $$
   \begin{CD}
   E_0 @> E_1 @> E_2 
   \end{CD}
   $$

   It turns out that if we are in the category of Banach spaces, we
   can define

* Acknowledgments
  Made using [[https://orgmode.org][org-mode]] and [[https://github.com/paulzql/org-html-themes][org-html-themes]].
